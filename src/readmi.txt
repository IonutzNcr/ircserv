Comment faire attention aux zombies (conceptuellement)
üß† 1. Le serveur ne fait jamais confiance au client

Principe fondamental r√©seau :

Un client peut mourir √† tout moment, sans pr√©venir.

üëâ Donc :

chaque socket doit √™tre consid√©r√©e comme potentiellement morte

aucune action ne doit supposer que le client est encore vivant

üß† 2. recv() est ta premi√®re ligne de d√©fense

Quand :

recv() retourne 0
‚Üí connexion ferm√©e proprement

recv() retourne -1
‚Üí erreur ‚Üí client probablement mort

üëâ √Ä ce moment-l√† :

supprimer le client

le retirer de tous les channels

lib√©rer la m√©moire

üß† 3. Poll / select = d√©tecteur de zombies

Avec poll() ou select() :

un fd devient :

lisible

ou en erreur

mais recv() ne renvoie plus rien

üëâ Signal clair que le client est zombie.

=====================================================================================

une fois le client enregistrer, il n'a plus droit de modifier son user mais son nick oui.
Pour set USER :
    la commande doit etre ecrite comme ca =>  USER toto 0 * :Toto
    pas comme ca => USER Toto => erreur 461 enought parameter

Pour NICK :

===> Si le serveur n'accepte pas le nouveau pseudo fourni par le client (par exemple, s'il contient des caract√®res invalides), 
il doit renvoyer une erreur num√©rique ERR_ERRONEUSNICKNAME et ignorer la commande NICK. Les serveurs DOIVENT autoriser au moins
 tous les caract√®res alphanum√©riques, les crochets et accolades ([]{}), les barres obliques inverses (\) et les barres verticales (|) 
 dans les pseudos, et PEUVENT interdire les chiffres en premier caract√®re. Les serveurs PEUVENT autoriser des caract√®res suppl√©mentaires, 
 √† condition qu'ils n'introduisent pas d'ambigu√Øt√© dans les autres commandes, notamment :

 pas de caract√®re # en d√©but de commande ni d'autre caract√®re annonc√© dans CHANTYPES

pas de deux-points (:) en d√©but de commande

pas d'espace ASCII

Si le serveur ne re√ßoit pas le param√®tre <nickname> avec la commande NICK, 
il doit renvoyer une erreur num√©rique ERR_NONICKNAMEGIVEN et ignorer la commande NICK.

Le message NICK peut √™tre envoy√© par le serveur aux clients pour confirmer la r√©ussite de leur commande NICK et 
informer les autres clients du changement de pseudonyme. Dans ce cas, la source du message sera l'ancien 
pseudonyme [ [ "!" utilisateur ] "@" h√¥te ] de l'utilisateur qui change de pseudonyme.


===> erreur 436 pas besoin de gerer je pense puisque on aura qu'un seul serveur.

=======================================================================================

5Ô∏è‚É£ Comment ta classe sera utilis√©e dans JOIN

Conceptuellement, JOIN fera :

- client enregistr√© ?
- channel existe ?
    NON ‚Üí cr√©er Channel
    OUI ‚Üí v√©rifier r√®gles
- +i ? ‚Üí invit√© ?
- +l ? ‚Üí plein ?
- +k ? ‚Üí cl√© valide ?
- addUser(client)
- si premier ‚Üí addOperator(client)


üëâ Toute cette logique vit dans Channel, pas dans JOIN.

JOIN doit poser des questions, Channel doit r√©pondre.

=====================================================
Pour PRIVTMSG

6Ô∏è‚É£.1 V√©rifier qu‚Äôil y a un MESSAGE
‚ùå Cas incorrect (message manquant)

Le client envoie :

PRIVMSG bob


üëâ Probl√®me :

il y a une cible (bob)

mais aucun texte

R√©action du serveur :

NE PAS envoyer quoi que ce soit √† bob

envoyer une erreur au client exp√©diteur

Message conceptuel :

‚ÄúTu n‚Äôas pas fourni de texte √† envoyer‚Äù

‚ùå Autre cas incorrect
PRIVMSG bob :


üëâ Le : est l√†, mais le message est vide
üëâ Toujours une erreur

‚úÖ Cas correct
PRIVMSG bob :Salut Bob !


üëâ Message valide

üî¥ 6Ô∏è‚É£.2 Envoyer le message au client cible
üéØ Situation

alice envoie :

PRIVMSG bob :Salut Bob

‚ùå Mauvais comportement serveur

le serveur v√©rifie tout

MAIS :

n‚Äôenvoie rien √† bob

ou envoie √† alice

üëâ bob ne re√ßoit jamais le message ‚ùå

‚úÖ Bon comportement serveur

le serveur envoie UNIQUEMENT √† bob

avec l‚Äôidentit√© d‚Äôalice

Message re√ßu par bob (conceptuellement) :

alice : Salut Bob

üëâ bob sait :

qui parle

quoi

========================================================================================


    // std::string user = line.substr(4); // on stock la string apres le NICK
    // user.erase(0, user.find_first_not_of(" \t")); // supprime les espaces ou tabulation jusqua un autre char autre que ca
    // if (!user.empty() && user[0] == ':') // a voir pour traiter un seul ou plusieur ':'
    //     user.erase(0, 1);
    // user.erase(user.find_last_not_of(" \t\r\n") + 1); // meme chose sauf que c'est a la fin mtn
    // if (user.empty()) {     // si pas de new nick => erreur 
    //     std::string msg = fd + " USER :Not enough parameters\r\n"; // ERR_NEEDMOREPARAMS (461)
    //     send(fd, msg.c_str(), msg.length(), 0);
    //     return true;
    // }