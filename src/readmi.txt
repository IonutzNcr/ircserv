Comment faire attention aux zombies (conceptuellement)
ğŸ§  1. Le serveur ne fait jamais confiance au client

Principe fondamental rÃ©seau :

Un client peut mourir Ã  tout moment, sans prÃ©venir.

ğŸ‘‰ Donc :

chaque socket doit Ãªtre considÃ©rÃ©e comme potentiellement morte

aucune action ne doit supposer que le client est encore vivant

ğŸ§  2. recv() est ta premiÃ¨re ligne de dÃ©fense

Quand :

recv() retourne 0
â†’ connexion fermÃ©e proprement

recv() retourne -1
â†’ erreur â†’ client probablement mort

ğŸ‘‰ Ã€ ce moment-lÃ  :

supprimer le client

le retirer de tous les channels

libÃ©rer la mÃ©moire

ğŸ§  3. Poll / select = dÃ©tecteur de zombies

Avec poll() ou select() :

un fd devient :

lisible

ou en erreur

mais recv() ne renvoie plus rien

ğŸ‘‰ Signal clair que le client est zombie.

=====================================================================================

une fois le client enregistrer, il n'a plus droit de modifier son user mais son nick oui.
Pour set USER :
    la commande doit etre ecrite comme ca =>  USER toto 0 * :Toto
    pas comme ca => USER Toto => erreur 461 enought parameter

Pour NICK :

===> Si le serveur n'accepte pas le nouveau pseudo fourni par le client (par exemple, s'il contient des caractÃ¨res invalides), 
il doit renvoyer une erreur numÃ©rique ERR_ERRONEUSNICKNAME et ignorer la commande NICK. Les serveurs DOIVENT autoriser au moins
 tous les caractÃ¨res alphanumÃ©riques, les crochets et accolades ([]{}), les barres obliques inverses (\) et les barres verticales (|) 
 dans les pseudos, et PEUVENT interdire les chiffres en premier caractÃ¨re. Les serveurs PEUVENT autoriser des caractÃ¨res supplÃ©mentaires, 
 Ã  condition qu'ils n'introduisent pas d'ambiguÃ¯tÃ© dans les autres commandes, notamment :

 pas de caractÃ¨re # en dÃ©but de commande ni d'autre caractÃ¨re annoncÃ© dans CHANTYPES

pas de deux-points (:) en dÃ©but de commande

pas d'espace ASCII

Si le serveur ne reÃ§oit pas le paramÃ¨tre <nickname> avec la commande NICK, 
il doit renvoyer une erreur numÃ©rique ERR_NONICKNAMEGIVEN et ignorer la commande NICK.

Le message NICK peut Ãªtre envoyÃ© par le serveur aux clients pour confirmer la rÃ©ussite de leur commande NICK et 
informer les autres clients du changement de pseudonyme. Dans ce cas, la source du message sera l'ancien 
pseudonyme [ [ "!" utilisateur ] "@" hÃ´te ] de l'utilisateur qui change de pseudonyme.


===> erreur 436 pas besoin de gerer je pense puisque on aura qu'un seul serveur.

=======================================================================================

5ï¸âƒ£ Comment ta classe sera utilisÃ©e dans JOIN

Conceptuellement, JOIN fera :

- client enregistrÃ© ?
- channel existe ?
    NON â†’ crÃ©er Channel
    OUI â†’ vÃ©rifier rÃ¨gles
- +i ? â†’ invitÃ© ?
- +l ? â†’ plein ?
- +k ? â†’ clÃ© valide ?
- addUser(client)
- si premier â†’ addOperator(client)


ğŸ‘‰ Toute cette logique vit dans Channel, pas dans JOIN.

JOIN doit poser des questions, Channel doit rÃ©pondre.

=====================================================
Pour PRIVTMSG

6ï¸âƒ£.1 VÃ©rifier quâ€™il y a un MESSAGE
âŒ Cas incorrect (message manquant)

Le client envoie :

PRIVMSG bob


ğŸ‘‰ ProblÃ¨me :

il y a une cible (bob)

mais aucun texte

RÃ©action du serveur :

NE PAS envoyer quoi que ce soit Ã  bob

envoyer une erreur au client expÃ©diteur

Message conceptuel :

â€œTu nâ€™as pas fourni de texte Ã  envoyerâ€

âŒ Autre cas incorrect
PRIVMSG bob :


ğŸ‘‰ Le : est lÃ , mais le message est vide
ğŸ‘‰ Toujours une erreur

âœ… Cas correct
PRIVMSG bob :Salut Bob !


ğŸ‘‰ Message valide

ğŸ”´ 6ï¸âƒ£.2 Envoyer le message au client cible
ğŸ¯ Situation

alice envoie :

PRIVMSG bob :Salut Bob

âŒ Mauvais comportement serveur

le serveur vÃ©rifie tout

MAIS :

nâ€™envoie rien Ã  bob

ou envoie Ã  alice

ğŸ‘‰ bob ne reÃ§oit jamais le message âŒ

âœ… Bon comportement serveur

le serveur envoie UNIQUEMENT Ã  bob

avec lâ€™identitÃ© dâ€™alice

Message reÃ§u par bob (conceptuellement) :

alice : Salut Bob

ğŸ‘‰ bob sait :

qui parle

quoi